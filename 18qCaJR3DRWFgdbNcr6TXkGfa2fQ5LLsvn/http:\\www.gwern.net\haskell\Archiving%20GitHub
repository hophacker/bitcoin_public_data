http://www.gwern.net/haskell/Archiving%20GitHub
HTTP/1.1 200 OK
Server: cloudflare-nginx
Date: Wed, 23 Jul 2014 01:29:44 GMT
Content-Type: text/html; charset=utf-8
Connection: close
Set-Cookie: __cfduid=dc2c798f6e29c0cfb174909afd54df0c21406078984552; expires=Mon, 23-Dec-2019 23:50:00 GMT; path=/; domain=.gwern.net; HttpOnly
x-amz-id-2: erc2O0H3Dj1ZcO9TEymc8uDQfRaW5yYfCWNvRyO9i58/S6Fwzl57e3x5lX7fFus+
x-amz-request-id: E39D0628FCC1F59C
x-amz-meta-s3cmd-attrs: uid:1000/gname:gwern/uname:gwern/gid:1000/mode:33152/mtime:1405189113/atime:1405189111/ctime:1405189113
Cache-Control: max-age=604800, public
Last-Modified: Sat, 12 Jul 2014 18:50:11 GMT
CF-RAY: 14e41bd5792d0097-IAD
Content-Encoding: gzip

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="generator" content="hakyll"/>
<meta name="google-site-verification" content="BOhOQI1uMfsqu_DopVApovk1mJD5ZBLfan0s9go3phk"/>
<meta name="author" content="gwern"/>
<meta name="description" content="Scraping and downloading Haskell-related repositories from GitHub"/>
<meta name="dc.date.issued" content="20 Mar 2011"/>
<meta name="dcterms.modified" content="03 Jun 2014"/>
<title>Archiving GitHub</title>
<link rel="stylesheet" type="text/css" href="../static/css/default.css"/>
<link href="../atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM/RSS Feed"/>
<link rel="shortcut icon" type="image/x-icon" href="../static/img/favicon.ico"/>
</head>
<body>
 
<div class="indent_class1"></div>
<div id="main">
<div id="sidebar">
<div id="logo"><img alt="Logo: a Gothic/Fraktur blackletter capital G/ùï≤" height="36" src="../images/logo.png" width="32"/></div>
<div id="sidebar-links">
<p>
<a href="../index" title="index: categorized list of articles">Home</a>
<a href="../About" title="Site ideals, source, content, traffic, examples, license">Site</a>
<a href="../Links" title="Who am I online, what have I done, what am I like? Contact information; sites I use; things I've worked on">Me</a>
</p>
<hr/>
<div id="sidebar-news">
<p>
<a href="../Changelog" title="What's new or updated">New:</a>
<a href="../atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM/RSS Feed">RSS</a>
<a href="http://eepurl.com/Kc155" title="Monthly mailing list: signup form">MAIL</a>
</p>
<hr/>
</div>
<div id="cse-sitesearch">
<script>
            (function() {
            var cx = '009114923999563836576:dv0a4ndtmly';
            var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
            gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
            })();
          </script>
<div style="width:0px;overflow:hidden;height:0px;">
<gcse:search></gcse:search>
</div>
<form id="searchbox_009114923999563836576:dv0a4ndtmly">
<input value="009114923999563836576:dv0a4ndtmly" name="cx" type="hidden"/>
<input value="FORID:11" name="cof" type="hidden"/>
<input id="q" style name="q" size="5" type="text" placeholder="search"/>
</form>
</div>
</div>
<hr/>
<div id="metadata">
<div id="abstract"><em>Scraping and downloading Haskell-related repositories from GitHub</em></div>
<br/>
<div id="tags"><i><a href="../tags/Haskell">Haskell</a>, <a href="../tags/archiving">archiving</a></i></div>
<br/>
<div id="page-created">created:
<br/>
<i>20 Mar 2011</i></div>
<div id="last-modified">modified:
<br/>
<i>03 Jun 2014</i></div>
<br/>
<div id="version">status:
<br/>
<i>finished</i></div>
<br/>
<div id="epistemological-status"><a href="../About#belief-tags" title="Explanation of 'belief' metadata">belief:</a>
<br/>
<i>highly likely</i>
</div>
<hr/>
</div>
<div id="donations">
<div id="bitcoin-donation-address">
<a href="http://en.wikipedia.org/wiki/Bitcoin">‡∏ø</a>: 18qCaJR3DRWFgdbNcr6TXkGfa2fQ5LLsvn
</div>
<div id="paypal">
<form style="display: inline" action="https://www.paypal.com/cgi-bin/webscr" method="post" onClick="_gaq.push(['_trackEvent', 'Click', 'PayPalClicked', '']);">
<div class="form-type">
<input type="hidden" name="cmd" value="_s-xclick"/>
<input type="hidden" name="hosted_button_id" value="8GSLCWGCC6AF8"/>
<input type="image" src="http://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" name="submit" alt="Help support my writings!"/>
</div>
</form>
</div>
<div id="Gittip">
<script data-gittip-username="gwern" data-gittip-widget="button" src="//gttp.co/v1.js"></script>
</div>
</div>
</div>
 
<div id="adsense">
<a href="http://41j.com/ads/ad.html"><img alt="Advertisement for 'HTerm, The Graphical Terminal'" src="http://41j.com/ads/ad.png" height="90" width="728"></a>
</div>
<div id="header">
<h1>Archiving GitHub</h1>
</div>
<div id="content">
<div id="TOC"><ul>
<li><a href="#why-download">Why download?</a></li>
<li><a href="#archiving-github">Archiving GitHub</a><ul>
<li><a href="#parsing-pages">Parsing pages</a></li>
<li><a href="#downloading-pages-the-lazy-way">Downloading pages (the lazy way)</a></li>
<li><a href="#spidering-the-lazy-way">Spidering (the lazy way)</a></li>
<li><a href="#filtering-repositories">Filtering repositories</a></li>
<li><a href="#transforming-links-the-lazy-way">Transforming links (the lazy way)</a></li>
<li><a href="#shelling-out-to-git">Shelling out to git</a><ul>
<li><a href="#unique-repositories">Unique repositories</a></li>
</ul></li>
<li><a href="#the-script">The script</a><ul>
<li><a href="#the-script-golfed">The script golfed</a></li>
</ul></li>
</ul></li>
<li><a href="#exercises-for-the-reader">Exercises for the reader</a></li>
</ul></div>
<blockquote>
<p>This Haskell tutorial was written in early March 2011, and while the below code worked then, it may not work with Github or the necessary Haskell libraries now. If you are interested in downloading from GitHub I suggest looking into the <a href="http://www.gwern.net/haskell/Archiving%20GitHub#comment-1099296212">GitHub API</a> or the Haskell <a href="https://github.com/fpco/github"><code>github</code></a> library.</p>
</blockquote>
<section id="why-download" class="level1">
<h1>Why download?</h1>
<p>Along the lines of <a href="../Archiving%20URLs">Archiving URLs</a>, I like to keep copies of <a href="http://en.wikipedia.org/wiki/Haskell%20%28programming%20language%29" title="Wikipedia: Haskell (programming language)">Haskell</a>-related source-code <a href="http://en.wikipedia.org/wiki/Revision%20control" title="Wikipedia: Revision control">repositories</a><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> because the files &amp; history might come in handy on occasion, and because having a large collection of repositories lets me search them for random purposes.</p>
<p>(For example, part of my lobbying for <a href="http://www.haskell.org/hoogle/?hoogle=Control.Monad.void" title="Hoogle: Control.Monad.void">Control.Monad.void</a><a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> was based on producing a list of dozens of source files which rewrote that particular idiom, and I have been able <a href="http://web.archive.org/web/20130623103613/http://www.haskell.org/pipermail/libraries/2011-April/016288.html" title="Proposal: add Int indexing functions to Data.Set">to</a> <a href="http://web.archive.org/web/20130128084734/http://www.haskell.org/pipermail/haskell-cafe/2011-February/089614.html" title="[Haskell-cafe] ANN: unordered-containers - a new, faster hashing-based containers library">usefully</a> <a href="http://web.archive.org/web/20130128084821/http://www.haskell.org/pipermail/haskell-cafe/2008-January/038948.html" title="[Haskell-cafe] RE: [Haskell] Announce: Yi 0.3">comment</a> <a href="http://web.archive.org/web/20130128084824/http://www.haskell.org/pipermail/haskell-cafe/2011-May/091660.html" title="[Haskell-cafe] Usage of rewrite rule specialization in Hackage">&amp;</a> <a href="../Haskell%20Summer%20of%20Code">judge</a> based on crude <a href="http://web.archive.org/web/20130128084846/http://www.haskell.org/pipermail/haskell-cafe/2011-May/091663.html" title="[Haskell-cafe] Haskell statistics for use of TypeFamilies and FunctionalDependencies">statistics</a> gathered by <a href="http://en.wikipedia.org/wiki/grepping" title="Wikipedia: grepping">grepping</a><a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> through my hundreds of repositories.)</p>
<p><a href="http://blog.patch-tag.com/2010/03/13/mirroring-patch-tag/">Previously</a> I wrote a simple script to download the repositories of the source repository hosting site <a href="http://www.patch-tag.com/">Patch-tag.com</a>. Patch-tag specializes in hosting <a href="http://en.wikipedia.org/wiki/Darcs" title="Wikipedia: Darcs">Darcs</a> repositories (usually Haskell-related). <a href="http://en.wikipedia.org/wiki/GitHub" title="Wikipedia: GitHub">GitHub</a> is a much larger &amp; more popular hosting site, and though it does not support Darcs but <a href="http://en.wikipedia.org/wiki/Git%20%28software%29" title="Wikipedia: Git (software)">git</a> (as the name indicates), it is so popular that it still hosts a great deal of Haskell. I‚Äôve downloaded a few repositories out of curiosity or because I was working on the contents of the repository (eg. <a href="https://github.com/jgm/gitit">gitit</a>), but there are too many to download manually. I needed a script.</p>
<p>Patch-tag was nice enough to supply a URL which provided exactly the URLs I needed, but I couldn‚Äôt expect such personalized support from GitHub. GitHub does supply an API of sorts for developers and hobbyists, said API provides no obvious way to get what I want: ‚ÄòURLs for all Haskell-related repos‚Äô. So, <a href="http://en.wikipedia.org/wiki/Data%20scraping" title="Wikipedia: Data scraping">scraping</a> it is - I‚Äôd write a script to munge some GitHub HTML and get the URLs I want <em>that</em> way.</p>
</section>
<section id="archiving-github" class="level1">
<h1>Archiving GitHub</h1>
<section id="parsing-pages" class="level2">
<h2>Parsing pages</h2>
<p>The closest I can get to a target URL is <a href="https://github.com/languages/Haskell/created">https://github.com/languages/Haskell/created</a>. We‚Äôll be parsing that. The first thing to do is to steal <a href="http://community.haskell.org/~ndm/tagsoup/">TagSoup</a> code from my <a href="../haskell/Wikipedia%20Archive%20Bot#parsing-html">previous scrapers</a>, so our very crudest version looks like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Text.HTML.TagSoup</span>
<span class="kw">import </span><span class="dt">Text.HTML.Download</span> (openURL)

main <span class="fu">=</span> <span class="kw">do</span> html <span class="ot">&lt;-</span> openURL <span class="st">&quot;https://github.com/languages/Haskell/created&quot;</span>
          <span class="kw">let</span> links <span class="fu">=</span> linkify html
          print links
linkify l <span class="fu">=</span> [x <span class="fu">|</span> <span class="dt">TagOpen</span> <span class="st">&quot;a&quot;</span> atts <span class="ot">&lt;-</span> parseTags l, (_,x) <span class="ot">&lt;-</span> atts]</code></pre>
</section>
<section id="downloading-pages-the-lazy-way" class="level2">
<h2>Downloading pages (the lazy way)</h2>
<p>We run it and it throws an exception! <code>*** Exception: getAddrInfo: does not exist (No address associated with hostname)</code></p>
<p>Oops. We got all wrapped up in parsing the HTML we forgot to make sure that downloading worked in the first place. Well, we‚Äôre lazy programmers, so now, on demand, we‚Äôll investigate that problem. The exception thrown sounds like a problem with the <code>openURL</code> call - ‚Äò<a href="http://en.wikipedia.org/wiki/hostname" title="Wikipedia: hostname">hostname</a>‚Äô is a networking term, not a parsing or printing term. So we try running just <code>openURL &quot;https://github.com/languages/Haskell/created&quot;</code> - same error. Not helpful.</p>
<p>We try a different implementation of <code>openURL</code>, mentioned in the <a href="../haskell/Wikipedia%20RSS%20Archive%20Bot#rewriting-network-code">other scraping script</a>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Network.HTTP</span> (getRequest, simpleHTTP)
openURL <span class="fu">=</span> simpleHTTP <span class="fu">.</span> getRequest</code></pre>
<p>Calling that again, we see:</p>
<pre><code>&gt; openURL &quot;https://github.com/languages/Haskell/created&quot;
Loading package HTTP-4000.1.1 ... linking ... done.
Right HTTP/1.1 301 Moved Permanently
Server: nginx/0.7.67
Date: Tue, 15 Mar 2011 22:54:31 GMT
Content-Type: text/html
Content-Length: 185
Connection: close
Location: https://github.com/languages/Haskell/created</code></pre>
<p>Oh dear. It seems that the <a href="http://hackage.haskell.org/package/HTTP" title="Hackage: HTTP"><code>HTTP</code></a> package just won‚Äôt handle HTTP<em>S</em>; nor does the description mention HTTPS nor any of the module names seem connected. Best to give up entirely on it.</p>
<p>If we google ‚ÄòHaskell https‚Äô, one of the first 20 hits happens to be a <a href="http://en.wikipedia.org/wiki/Stack%20Overflow" title="Wikipedia: Stack Overflow">Stack Overflow</a> question/page which sounds promising: <a href="http://stackoverflow.com/questions/3988115/haskell-network-browser-https-connection">‚ÄúHaskell Network.Browser HTTPS Connection‚Äù</a>. The <a href="http://stackoverflow.com/questions/3988115/haskell-network-browser-https-connection/3988829#3988829">one answer</a> says to simply use the <a href="http://hackage.haskell.org/package/curl" title="Hackage: curl">Haskell binding</a> to <a href="http://en.wikipedia.org/wiki/cURL" title="Wikipedia: cURL">curl</a>. Well, fine. I already had that installed because Darcs uses the binding for downloads. I‚Äôll use that package.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<p>We go to the <a href="http://hackage.haskell.org/packages/archive/curl/1.3.6/doc/html/Network-Curl.html">top level module</a> hoping for an easy download. Scrolling down, one‚Äôs eye is caught by a <a href="http://hackage.haskell.org/packages/archive/curl/1.3.6/doc/html/Network-Curl.html#v:curlGetString">curlGetString</a>, which while not necessarily a promising name, does have an interesting type: <code>URLString -&gt; [CurlOption] -&gt; IO (CurlCode, String)</code>.</p>
<p>Note especially the return value - from past experience with the HTML package, one would give a good chance that the <code>URLString</code> is just a type synonym for a URL string and the String return just the HTML source we want. What <code>CurlOption</code> might be, I have no idea, but let‚Äôs try simply omitting them all. So we load the module in GHCi (<code>:module + Network.Curl</code>) and see what <code>curlGetString &quot;https://github.com/languages/Haskell/created&quot; []</code> does:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="dt">CurlOK</span>,<span class="st">&quot;&lt;!DOCTYPE html&gt;</span>
<span class="st">&lt;html&gt;</span>
<span class="st">  &lt;head&gt;</span>
<span class="st">    &lt;meta charset='utf-8'&gt;</span>
<span class="st">    &lt;meta http-equiv=\&quot;X-UA-Compatible\&quot; content=\&quot;chrome=1\&quot;&gt;</span>
<span class="st">        &lt;title&gt;Recently Created Haskell Repositories - GitHub&lt;/title&gt;</span>
<span class="st">    &lt;link rel=\&quot;search\&quot; type=\&quot;application/opensearchdescription+xml\&quot;</span>
<span class="st">                          href=\&quot;/opensearch.xml\&quot; title=\&quot;GitHub\&quot; /&gt;</span>
<span class="st">    &lt;link rel=\&quot;fluid-icon\&quot; href=\&quot;https://github.com/fluidicon.png\&quot; title=\&quot;GitHub\&quot; /&gt;</span>
<span class="st">  ...&quot;</span>)</code></pre>
<p>Great! As they say, ‚Äòtry the simplest possible thing that could possibly work‚Äô, and this seems to. We don‚Äôt really care about the exit code, since this is a hacky script<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>; we‚Äôll throw it away and only keep the second part of the tuple with the usual <code>snd</code>. It‚Äôs in IO so we need to use <code>liftM</code> or <code>fmap</code> before we can apply <code>snd</code>. Combined with our previous Tagsoup code, we get:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Text.HTML.TagSoup</span>
<span class="kw">import </span><span class="dt">Network.Curl</span> (curlGetString, <span class="dt">URLString</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span> html <span class="ot">&lt;-</span> openURL <span class="st">&quot;https://github.com/languages/Haskell/created&quot;</span>
          <span class="kw">let</span> links <span class="fu">=</span> linkify html
          print links

<span class="ot">openURL ::</span> <span class="dt">URLString</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span>
openURL target <span class="fu">=</span> fmap snd <span class="fu">$</span> curlGetString target []

<span class="ot">linkify ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
linkify l <span class="fu">=</span> [x <span class="fu">|</span> <span class="dt">TagOpen</span> <span class="st">&quot;a&quot;</span> atts <span class="ot">&lt;-</span> parseTags l, (_,x) <span class="ot">&lt;-</span> atts]</code></pre>
</section>
<section id="spidering-the-lazy-way" class="level2">
<h2>Spidering (the lazy way)</h2>
<p>What‚Äôs the output of this?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="st">&quot;logo boring&quot;</span>,<span class="st">&quot;https://github.com&quot;</span>,<span class="st">&quot;/plans&quot;</span>,<span class="st">&quot;/explore&quot;</span>,<span class="st">&quot;/features&quot;</span>,<span class="st">&quot;/blog&quot;</span>,
    <span class="st">&quot;/login?return_to=https://github.com/languages/Haskell/created&quot;</span>,
    <span class="st">&quot;/languages/Haskell&quot;</span>,<span class="st">&quot;/explore&quot;</span>,<span class="st">&quot;explore_main&quot;</span>,<span class="st">&quot;/repositories&quot;</span>,<span class="st">&quot;explore_repos&quot;</span>,<span class="st">&quot;/languages&quot;</span>,
    <span class="st">&quot;selected&quot;</span>,<span class="st">&quot;explore_languages&quot;</span>,<span class="st">&quot;/timeline&quot;</span>,<span class="st">&quot;explore_timeline&quot;</span>,<span class="st">&quot;/search&quot;</span>,<span class="st">&quot;code_search&quot;</span>,
    <span class="st">&quot;/tips&quot;</span>,<span class="st">&quot;explore_tips&quot;</span>,<span class="st">&quot;/languages/Haskell&quot;</span>,<span class="st">&quot;/languages/Haskell/created&quot;</span>,
    <span class="st">&quot;selected&quot;</span>,<span class="st">&quot;/languages/Haskell/updated&quot;</span>, <span class="st">&quot;/languages&quot;</span>,<span class="st">&quot;/languages/ActionScript/created&quot;</span>,
    <span class="st">&quot;/languages/Ada/created&quot;</span>,<span class="st">&quot;/languages/Arc/created&quot;</span>,<span class="st">&quot;/languages/ASP/created&quot;</span>,
    <span class="st">&quot;/languages/Assembly/created&quot;</span>,
    <span class="st">&quot;/languages/Boo/created&quot;</span>,<span class="st">&quot;/languages/C/created&quot;</span>,<span class="st">&quot;/languages/C%23/created&quot;</span>,
    <span class="st">&quot;/languages/C++/created&quot;</span>,<span class="st">&quot;/languages/Clojure/created&quot;</span>,
    <span class="st">&quot;/languages/CoffeeScript/created&quot;</span>,
    <span class="st">&quot;/languages/ColdFusion/created&quot;</span>,<span class="st">&quot;/languages/Common%20Lisp/created&quot;</span>,<span class="st">&quot;/languages/D/created&quot;</span>,
    <span class="st">&quot;/languages/Delphi/created&quot;</span>,<span class="st">&quot;/languages/Duby/created&quot;</span>,
    <span class="st">&quot;/languages/Eiffel/created&quot;</span>,
    <span class="st">&quot;/languages/Emacs%20Lisp/created&quot;</span>,<span class="st">&quot;/languages/Erlang/created&quot;</span>,<span class="st">&quot;/languages/F%23/created&quot;</span>,
    <span class="st">&quot;/languages/Factor/created&quot;</span>,<span class="st">&quot;/languages/FORTRAN/created&quot;</span>,
    <span class="st">&quot;/languages/Go/created&quot;</span>,
    <span class="st">&quot;/languages/Groovy/created&quot;</span>,<span class="st">&quot;/languages/HaXe/created&quot;</span>,<span class="st">&quot;/languages/Io/created&quot;</span>,
    <span class="st">&quot;/languages/Java/created&quot;</span>,<span class="st">&quot;/languages/JavaScript/created&quot;</span>,
    <span class="st">&quot;/languages/Lua/created&quot;</span>,
    <span class="st">&quot;/languages/Max/MSP/created&quot;</span>,<span class="st">&quot;/languages/Nu/created&quot;</span>,<span class="st">&quot;/languages/Objective-C/created&quot;</span>,
    <span class="st">&quot;/languages/Objective-J/created&quot;</span>,<span class="st">&quot;/languages/OCaml/created&quot;</span>,
    <span class="st">&quot;/languages/ooc/created&quot;</span>,
    <span class="st">&quot;/languages/Perl/created&quot;</span>,<span class="st">&quot;/languages/PHP/created&quot;</span>,<span class="st">&quot;/languages/Pure%20Data/created&quot;</span>,
    <span class="st">&quot;/languages/Python/created&quot;</span>,<span class="st">&quot;/languages/R/created&quot;</span>,
    <span class="st">&quot;/languages/Racket/created&quot;</span>,
    <span class="st">&quot;/languages/Ruby/created&quot;</span>,<span class="st">&quot;/languages/Scala/created&quot;</span>,<span class="st">&quot;/languages/Scheme/created&quot;</span>,
    <span class="st">&quot;/languages/sclang/created&quot;</span>,<span class="st">&quot;/languages/Self/created&quot;</span>,
    <span class="st">&quot;/languages/Shell/created&quot;</span>,
    <span class="st">&quot;/languages/Smalltalk/created&quot;</span>,<span class="st">&quot;/languages/SuperCollider/created&quot;</span>,<span class="st">&quot;/languages/Tcl/created&quot;</span>,
    <span class="st">&quot;/languages/Vala/created&quot;</span>,<span class="st">&quot;/languages/Verilog/created&quot;</span>,
    <span class="st">&quot;/languages/VHDL/created&quot;</span>,
    <span class="st">&quot;/languages/VimL/created&quot;</span>,<span class="st">&quot;/languages/Visual%20Basic/created&quot;</span>,<span class="st">&quot;/languages/XQuery/created&quot;</span>,
    <span class="st">&quot;/brownnrl&quot;</span>,<span class="st">&quot;/brownnrl/Real-World-Haskell&quot;</span>,<span class="st">&quot;/joh&quot;</span>,
    <span class="st">&quot;/joh/tribot&quot;</span>,<span class="st">&quot;/bjornbm&quot;</span>,<span class="st">&quot;/bjornbm/publicstuff&quot;</span>,<span class="st">&quot;/codemac&quot;</span>,<span class="st">&quot;/codemac/yi&quot;</span>,<span class="st">&quot;/poconnell93&quot;</span>,
    <span class="st">&quot;/poconnell93/chat&quot;</span>,<span class="st">&quot;/jillianfu&quot;</span>,<span class="st">&quot;/jillianfu/Angel&quot;</span>,<span class="st">&quot;/jaspervdj&quot;</span>,<span class="st">&quot;/jaspervdj/sup-host&quot;</span>,<span class="st">&quot;/serras&quot;</span>,
    <span class="st">&quot;/serras/scion-ghc-7-requisites&quot;</span>,<span class="st">&quot;/serras&quot;</span>,<span class="st">&quot;/serras/scion&quot;</span>,<span class="st">&quot;/iand675&quot;</span>,<span class="st">&quot;/iand675/cgen&quot;</span>,<span class="st">&quot;/shangaslammi&quot;</span>,
    <span class="st">&quot;/shangaslammi/haskeroids&quot;</span>,<span class="st">&quot;/rukav&quot;</span>,<span class="st">&quot;/rukav/ReplayTrace&quot;</span>,<span class="st">&quot;/jaspervdj&quot;</span>,<span class="st">&quot;/jaspervdj/wol&quot;</span>,<span class="st">&quot;/tomlokhorst&quot;</span>,
    <span class="st">&quot;/tomlokhorst/wol&quot;</span>,<span class="st">&quot;/bos&quot;</span>,<span class="st">&quot;/bos/concurrent-barrier&quot;</span>,<span class="st">&quot;/jkingry&quot;</span>,<span class="st">&quot;/jkingry/projectEuler&quot;</span>,<span class="st">&quot;/olshanskydr&quot;</span>,
    <span class="st">&quot;/olshanskydr/xml-enumerator&quot;</span>,<span class="st">&quot;/lorenz&quot;</span>,<span class="st">&quot;/lorenz/fypmaincode&quot;</span>,<span class="st">&quot;/jaspervdj&quot;</span>,
    <span class="st">&quot;/jaspervdj/data-object-json&quot;</span>,<span class="st">&quot;/jaspervdj&quot;</span>,<span class="st">&quot;/jaspervdj/data-object-yaml&quot;</span>,
    <span class="st">&quot;/languages/Haskell/created?page=2&quot;</span>,<span class="st">&quot;next&quot;</span>,<span class="st">&quot;/languages/Haskell/created?page=3&quot;</span>,
    <span class="st">&quot;/languages/Haskell/created?page=4&quot;</span>,<span class="st">&quot;/languages/Haskell/created?page=5&quot;</span>,
    <span class="st">&quot;/languages/Haskell/created?page=6&quot;</span>,<span class="st">&quot;/languages/Haskell/created?page=7&quot;</span>,
    <span class="st">&quot;/languages/Haskell/created?page=8&quot;</span>,<span class="st">&quot;/languages/Haskell/created?page=9&quot;</span>,
    <span class="st">&quot;/languages/Haskell/created?page=208&quot;</span>,<span class="st">&quot;/languages/Haskell/created?page=209&quot;</span>,
    <span class="st">&quot;/languages/Haskell/created?page=2&quot;</span>,<span class="st">&quot;l&quot;</span>,<span class="st">&quot;next&quot;</span>,<span class="st">&quot;http://www.rackspace.com&quot;</span>,<span class="st">&quot;logo&quot;</span>,
    <span class="st">&quot;http://www.rackspace.com &quot;</span>,<span class="st">&quot;http://www.rackspacecloud.com&quot;</span>,<span class="st">&quot;https://github.com/blog&quot;</span>,
    <span class="st">&quot;/login/multipass?to=http%3A%2F%2Fsupport.github.com&quot;</span>,<span class="st">&quot;https://github.com/training&quot;</span>,
    <span class="st">&quot;http://jobs.github.com&quot;</span>,<span class="st">&quot;http://shop.github.com&quot;</span>,
    <span class="st">&quot;https://github.com/contact&quot;</span>,<span class="st">&quot;http://develop.github.com&quot;</span>,<span class="st">&quot;http://status.github.com&quot;</span>,
    <span class="st">&quot;/site/terms&quot;</span>,<span class="st">&quot;/site/privacy&quot;</span>,<span class="st">&quot;https://github.com/security&quot;</span>,
    <span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=de&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=fr&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=ja&quot;</span>,
    <span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=pt-BR&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=ru&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=zh&quot;</span>,
    <span class="st">&quot;#&quot;</span>,<span class="st">&quot;minibutton btn-forward js-all-locales&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=en&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=af&quot;</span>,
    <span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=ca&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=cs&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=de&quot;</span>,
    <span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=es&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=fr&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=hr&quot;</span>,
    <span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=hu&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=id&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=it&quot;</span>,
    <span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=ja&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=nl&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=no&quot;</span>,
    <span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=pl&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=pt-BR&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=ru&quot;</span>,
    <span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=sr&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=sv&quot;</span>,<span class="st">&quot;nofollow&quot;</span>,<span class="st">&quot;?locale=zh&quot;</span>,
    <span class="st">&quot;#&quot;</span>,<span class="st">&quot;js-see-all-keyboard-shortcuts&quot;</span>]</code></pre>
<p>Quite a mouthful, but we can easily filter things down. ‚Äú/languages/Haskell/created?page=3‚Äù is an example of a link to the next page listing Haskell repositories; presumably the current page would be ‚Äú?page=1‚Äù, and the highest listed seems to be ‚Äú/languages/Haskell/created?page=209‚Äù. The actual repositories look like ‚Äú/jaspervdj/data-object-yaml‚Äù.</p>
<p>The regularity of the ‚Äúcreated‚Äù numbering suggests that we can avoid any actual spidering. Instead, we could just figure out what the last page is, the highest page, and then generate all the page names in between because they follow a simple scheme.</p>
<p>Assume we have the final number, <em>n</em>, we already know we get the full list through <code>[1..n]</code>; then we want to prepend ‚Äúlanguages/Haskell/created?page=‚Äù, but it‚Äôs a type error to simply write <code>map (&quot;languages/Haskell/created?page=&quot;++) [1..n]</code>. There is only one type-variable in <code>(++) :: [a] -&gt; [a] -&gt; [a]</code>. To convert the Integers to a proper String, we do <code>map show</code>, so that gives us our generator:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">listPages ::</span> [<span class="dt">String</span>]
listPages <span class="fu">=</span> map (\x <span class="ot">-&gt;</span> <span class="st">&quot;https://github.com/languages/Haskell/created?page=&quot;</span> <span class="fu">++</span> show x) [<span class="dv">1</span><span class="fu">..</span>]</code></pre>
<p>(This will throw a warning using <code>-Wall</code> because GHC has to guess whether the 1 is an Int or Integer. This can be quieted by writing <code>(1::Int)</code> instead.)</p>
<p>But what is <code>x</code>? We don‚Äôt know the final, highest, oldest page. We don‚Äôt know how much of our infinite lazy list to <code>take</code>. It‚Äôs easy enough to <a href="http://www.haskell.org/hoogle/?hoogle=filter" title="Hoogle: filter">filter</a> the list to get only the index: <code>filter (isPrefixOf &quot;/languages/Haskell/created?page=&quot;)</code>.</p>
<p>Then we call <a href="http://www.haskell.org/hoogle/?hoogle=last" title="Hoogle: last">last</a>, right? (Or something like <code>head . reverse</code> if we didn‚Äôt know <code>last</code> or if we didn‚Äôt think to check the hits for <a href="http://www.haskell.org/hoogle/?hoogle=%5Ba%5D%20-%3E%20a" title="Hoogle: [a] -&gt; a">[a] -&gt; a</a>). But if you look back at the original scraping output, you see an example of how a simple approach can go wrong; we read ‚Äú/languages/Haskell/created?page=209‚Äù and then we read ‚Äú/languages/Haskell/created?page=2‚Äù! 2 is less than 209, of course, and is the wrong answer. GitHub is not padding the numbers to look like ‚Äúcreated?page=002‚Äù, so our simple-minded approach doesn‚Äôt work.</p>
<p>So we need to extract the number. Easy enough: the prefix is statically known and never changes, so we can hardwire some crude parsing using <a href="http://www.haskell.org/hoogle/?hoogle=drop" title="Hoogle: drop">drop</a>: <code>drop 32</code>. How to turn the remaining String into an Int? Hopefully one knows about <a href="http://www.haskell.org/hoogle/?hoogle=read" title="Hoogle: read">read</a>, but even here Hoogle will save our bacon if we think to look through the list of hits for <a href="http://www.haskell.org/hoogle/?hoogle=String%20-%3E%20Int" title="Hoogle: String -&gt; Int">String -&gt; Int</a> - <code>read</code> turns up as hit #10 or #11. <em>Then</em>, now that we have turned our [String] into [Int], we could sort it and take the last entry, or again go to the standard library and use <a href="http://www.haskell.org/hoogle/?hoogle=maximum" title="Hoogle: maximum">maximum</a> (like <code>read</code>, it will turn up for <a href="http://www.haskell.org/hoogle/?hoogle=%5BInt%5D%20-%3E%20Int" title="Hoogle: [Int] -&gt; Int">[Int] -&gt; Int</a>, if not as highly ranked as one might hope). Tweaking the syntax a little, our final result is:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lastPage ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
lastPage <span class="fu">=</span> maximum <span class="fu">.</span> map (read <span class="fu">.</span> drop <span class="dv">32</span>) <span class="fu">.</span> filter (<span class="st">&quot;/languages/Haskell/created?page=&quot;</span> <span class="ot">`isPrefixOf`</span>)</code></pre>
<p>If we didn‚Äôt want to hardwire this for Haskell, we‚Äôd probably write the function with an additional parameter and replace the Int with a runtime calculation of what to remove:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lastPageGeneric ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
lastPageGeneric lang <span class="fu">=</span> maximum <span class="fu">.</span> map (read <span class="fu">.</span> drop (length lang)) <span class="fu">.</span> filter (lang <span class="ot">`isPrefixOf`</span>)</code></pre>
<p>So let‚Äôs put what we have together. The program can download an initial index page, parse it, find the name of the last index page, and generate the URLs of all index pages, and print those out (to prove that it all works):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span> (isPrefixOf)
<span class="kw">import </span><span class="dt">Network.Curl</span> (curlGetString, <span class="dt">URLString</span>)
<span class="kw">import </span><span class="dt">Text.HTML.TagSoup</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span> html <span class="ot">&lt;-</span> openURL <span class="st">&quot;https://github.com/languages/Haskell/created&quot;</span>
          <span class="kw">let</span> lst <span class="fu">=</span> lastPage <span class="fu">$</span> linkify html
          <span class="kw">let</span> indxPgs <span class="fu">=</span> take lst listPages
          print indxPgs

<span class="ot">openURL ::</span> <span class="dt">URLString</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span>
openURL target <span class="fu">=</span> fmap snd <span class="fu">$</span> curlGetString target []

<span class="ot">linkify ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
linkify l <span class="fu">=</span> [x <span class="fu">|</span> <span class="dt">TagOpen</span> <span class="st">&quot;a&quot;</span> atts <span class="ot">&lt;-</span> parseTags l, (_,x) <span class="ot">&lt;-</span> atts]

<span class="ot">lastPage ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
lastPage <span class="fu">=</span> maximum <span class="fu">.</span> map (read <span class="fu">.</span> drop <span class="dv">32</span>) <span class="fu">.</span> filter (<span class="st">&quot;/languages/Haskell/created?page=&quot;</span> <span class="ot">`isPrefixOf`</span>)

<span class="ot">listPages ::</span> [<span class="dt">String</span>]
listPages <span class="fu">=</span> map (\x <span class="ot">-&gt;</span> <span class="st">&quot;https://github.com/languages/Haskell/created?page=&quot;</span> <span class="fu">++</span> show x) [(<span class="dv">1</span><span class="ot">::</span><span class="dt">Int</span>)<span class="fu">..</span>]</code></pre>
<p>So where were we? We had a <code>[String]</code> (in a variable named <code>indxPgs</code>) which represents all the index pages. We can get the HTML source of each page just by reusing <code>openURL</code> (it works on the first one, so it stands to reason it‚Äôd work on all index pages), which is trivial by this point: <code>mapM openURL indxPgs</code>.</p>
</section>
<section id="filtering-repositories" class="level2">
<h2>Filtering repositories</h2>
<p>In the TagSoup result, we saw the addresses of the repositories listed on the first index page:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="st">&quot;/brownnrl&quot;</span>,<span class="st">&quot;/brownnrl/Real-World-Haskell&quot;</span>,<span class="st">&quot;/joh&quot;</span>,<span class="st">&quot;/joh/tribot&quot;</span>,<span class="st">&quot;/bjornbm&quot;</span>,<span class="st">&quot;/bjornbm/publicstuff&quot;</span>,
    <span class="st">&quot;/codemac&quot;</span>,<span class="st">&quot;/codemac/yi&quot;</span>,<span class="st">&quot;/poconnell93&quot;</span>,<span class="st">&quot;/poconnell93/chat&quot;</span>,<span class="st">&quot;/jillianfu&quot;</span>,<span class="st">&quot;/jillianfu/Angel&quot;</span>,
    <span class="st">&quot;/jaspervdj&quot;</span>,<span class="st">&quot;/jaspervdj/sup-host&quot;</span>,<span class="st">&quot;/serras&quot;</span>,<span class="st">&quot;/serras/scion-ghc-7-requisites&quot;</span>,<span class="st">&quot;/serras&quot;</span>,<span class="st">&quot;/serras/scion&quot;</span>,
    <span class="st">&quot;/iand675&quot;</span>,<span class="st">&quot;/iand675/cgen&quot;</span>,<span class="st">&quot;/shangaslammi&quot;</span>,<span class="st">&quot;/shangaslammi/haskeroids&quot;</span>,<span class="st">&quot;/rukav&quot;</span>,<span class="st">&quot;/rukav/ReplayTrace&quot;</span>,
    <span class="st">&quot;/jaspervdj&quot;</span>,<span class="st">&quot;/jaspervdj/wol&quot;</span>,<span class="st">&quot;/tomlokhorst&quot;</span>,<span class="st">&quot;/tomlokhorst/wol&quot;</span>,<span class="st">&quot;/bos&quot;</span>,<span class="st">&quot;/bos/concurrent-barrier&quot;</span>,
    <span class="st">&quot;/jkingry&quot;</span>,<span class="st">&quot;/jkingry/projectEuler&quot;</span>,<span class="st">&quot;/olshanskydr&quot;</span>,<span class="st">&quot;/olshanskydr/xml-enumerator&quot;</span>,<span class="st">&quot;/lorenz&quot;</span>,
    <span class="st">&quot;/lorenz/fypmaincode&quot;</span>,<span class="st">&quot;/jaspervdj&quot;</span>,<span class="st">&quot;/jaspervdj/data-object-json&quot;</span>,<span class="st">&quot;/jaspervdj&quot;</span>,
    <span class="st">&quot;/jaspervdj/data-object-yaml&quot;</span>]</code></pre>
<p>Without looking at the rendered page in our browser, it‚Äôs obvious that GitHub is linking first to whatever user owns or created the repository, and then linking to the repository itself. We don‚Äôt want the users, but the repositories. Fortunately, it‚Äôs equally obvious that this is true: no user page has two forward-slashes in it, while all repository pages have two forward-slashes in it.</p>
<p>So we want to count the forward-slashes and keep every address with exactly 2 forward-slashes. The type for our function takes a list, a possible entry in that list, and returns a count. This is easy to do with primitive recursion and an accumulator, or perhaps <code>length</code> combined with <code>filter</code>; but the base library already has functions for <a href="http://www.haskell.org/hoogle/?hoogle=a%20-%3E%20%5Ba%5D%20-%3E%20Int" title="Hoogle: a -&gt; [a] -&gt; Int">a -&gt; [a] -&gt; Int</a>. <a href="http://www.haskell.org/hoogle/?hoogle=elemIndex" title="Hoogle: elemIndex">elemIndex</a> annoyingly returns a <code>Maybe Int</code>, so we‚Äôll use <a href="http://www.haskell.org/hoogle/?hoogle=elemIndices" title="Hoogle: elemIndices">elemIndices</a> instead and call <code>length</code> on its output: <code>length (elemIndices '/' x) == 2</code>.</p>
<p>This is not quite right. If we run this on the original parsed output, we get</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="st">&quot;https://github.com&quot;</span>,<span class="st">&quot;/languages/Haskell&quot;</span>,<span class="st">&quot;/languages/Haskell&quot;</span>,<span class="st">&quot;/plategreaves/unordered-containers&quot;</span>,
    <span class="st">&quot;/vincenthz/hs-tls-extra&quot;</span>,<span class="st">&quot;/aculich/fix-symbols-gitit&quot;</span>,
    <span class="st">&quot;/sphynx/euler-hs&quot;</span>,<span class="st">&quot;/DRMacIver/unordered-containers&quot;</span>,<span class="st">&quot;/hamishmack/yesod-slides&quot;</span>,<span class="st">&quot;/GNUManiacs/hoppla&quot;</span>,
    <span class="st">&quot;/DRMacIver/hs-rank-aggregation&quot;</span>,<span class="st">&quot;/naota/hackage-autoebuild&quot;</span>,
    <span class="st">&quot;/magthe/hsini&quot;</span>,<span class="st">&quot;/dagit/gnuplot-test&quot;</span>,<span class="st">&quot;/imbaczek/HBPoker&quot;</span>,<span class="st">&quot;/sergeyastanin/simpleea&quot;</span>,<span class="st">&quot;/cbaatz/hamu8080&quot;</span>,
    <span class="st">&quot;/aristidb/xml-enumerator&quot;</span>,
    <span class="st">&quot;/elliottt/value-supply&quot;</span>,<span class="st">&quot;/gnumaniacs-org/hoppla&quot;</span>,<span class="st">&quot;/emillon/tyson&quot;</span>,<span class="st">&quot;/quelgar/hifive&quot;</span>,
    <span class="st">&quot;/quelgar/haskell-websockets&quot;</span>,<span class="st">&quot;http://www.rackspace.com&quot;</span>,
    <span class="st">&quot;http://www.rackspace.com &quot;</span>,<span class="st">&quot;http://www.rackspacecloud.com&quot;</span>,
    <span class="st">&quot;/login/multipass?to=http%3A%2F%2Fsupport.github.com&quot;</span>,<span class="st">&quot;http://jobs.github.com&quot;</span>,
    <span class="st">&quot;http://shop.github.com&quot;</span>,<span class="st">&quot;http://develop.github.com&quot;</span>,
    <span class="st">&quot;http://status.github.com&quot;</span>,<span class="st">&quot;/site/terms&quot;</span>,<span class="st">&quot;/site/privacy&quot;</span>]</code></pre>
<p>It doesn‚Äôt look like we mistakenly omitted a repository, but it does look like we mistakenly included things we should not have. We need to filter out anything beginning with a ‚Äúhttp://‚Äù, ‚Äúhttps://‚Äù, ‚Äú/site/‚Äù, ‚Äú/languages/‚Äù, or ‚Äú/login/‚Äù.<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a></p>
<p>We could call <code>filter</code> multiple times, or use a tricky <code>foldr</code> to accumulate only results which don‚Äôt match any of the items in our list <code>[&quot;/languages/&quot;, &quot;/login/&quot;, &quot;/site/&quot;, &quot;http://&quot;, &quot;https://&quot;]</code>. But I already wrote <a href="../haskell/Wikipedia%20RSS%20Archive%20Bot">the solution</a> to this problem back in the original WP RSS archive-bot where I noticed that my <a href="../haskell/Wikipedia%20Archive%20Bot#duplicate-urls">original giant <code>filter</code> call</a> could be replaced by a much more elegant use of <a href="http://en.wikipedia.org/wiki/any" title="Wikipedia: any">any</a></p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"> <span class="kw">where</span><span class="ot">  uniq ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> [<span class="dt">String</span>]
        uniq <span class="fu">=</span> filter (\x <span class="ot">-&gt;</span>not <span class="fu">$</span> any (flip isInfixOf x) exceptions)

<span class="ot">        exceptions ::</span> [<span class="dt">String</span>]
        exceptions <span class="fu">=</span> [<span class="st">&quot;wikimediafoundation&quot;</span>, <span class="st">&quot;http://www.mediawiki.org/&quot;</span>, <span class="st">&quot;wikipedia&quot;</span>,
                      <span class="st">&quot;&amp;curid=&quot;</span>, <span class="st">&quot;index.php?title=&quot;</span>, <span class="st">&quot;&amp;action=&quot;</span>]</code></pre>
<p>In our case, we replace <code>isInfixOf</code> with <code>isPrefixOf</code>, and we have different constants defined in <code>exceptions</code>. To put it all together into a new filtering function, we have:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">repos ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
repos <span class="fu">=</span> uniq <span class="fu">.</span> linkify
  <span class="kw">where</span><span class="ot">  uniq ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> [<span class="dt">String</span>]
         uniq <span class="fu">=</span> filter count <span class="fu">.</span> filter (\x <span class="ot">-&gt;</span> not <span class="fu">$</span> any (<span class="ot">`isPrefixOf`</span> x) exceptions)
<span class="ot">         exceptions ::</span> [<span class="dt">String</span>]
         exceptions <span class="fu">=</span> [<span class="st">&quot;/languages/&quot;</span>, <span class="st">&quot;/login/&quot;</span>, <span class="st">&quot;/site/&quot;</span>, <span class="st">&quot;http://&quot;</span>, <span class="st">&quot;https://&quot;</span>]
<span class="ot">         count ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
         count x <span class="fu">=</span> length (elemIndices <span class="ch">'/'</span> x) <span class="fu">==</span> <span class="dv">2</span></code></pre>
<p>Our new minimalist program, which will test out <code>repos</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span> (elemIndices, isPrefixOf)
<span class="kw">import </span><span class="dt">Network.Curl</span> (curlGetString, <span class="dt">URLString</span>)
<span class="kw">import </span><span class="dt">Text.HTML.TagSoup</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span> html <span class="ot">&lt;-</span> openURL <span class="st">&quot;https://github.com/languages/Haskell/created&quot;</span>
          print <span class="fu">$</span> repos html

<span class="ot">openURL ::</span> <span class="dt">URLString</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span>
openURL target <span class="fu">=</span> fmap snd <span class="fu">$</span> curlGetString target []

<span class="ot">linkify ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
linkify l <span class="fu">=</span> [x <span class="fu">|</span> <span class="dt">TagOpen</span> <span class="st">&quot;a&quot;</span> atts <span class="ot">&lt;-</span> parseTags l, (_,x) <span class="ot">&lt;-</span> atts]

<span class="ot">repos ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
repos <span class="fu">=</span> uniq <span class="fu">.</span> linkify
  <span class="kw">where</span><span class="ot">  uniq ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> [<span class="dt">String</span>]
         uniq <span class="fu">=</span> filter count <span class="fu">.</span> filter (\x <span class="ot">-&gt;</span> not <span class="fu">$</span> any (<span class="ot">`isPrefixOf`</span> x) exceptions)
<span class="ot">         exceptions ::</span> [<span class="dt">String</span>]
         exceptions <span class="fu">=</span> [<span class="st">&quot;/languages/&quot;</span>, <span class="st">&quot;/login/&quot;</span>, <span class="st">&quot;/site/&quot;</span>, <span class="st">&quot;http://&quot;</span>, <span class="st">&quot;https://&quot;</span>]
<span class="ot">         count ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
         count x <span class="fu">=</span> length (elemIndices <span class="ch">'/'</span> x) <span class="fu">==</span> <span class="dv">2</span></code></pre>
<p>The output:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="st">&quot;/plategreaves/unordered-containers&quot;</span>,<span class="st">&quot;/vincenthz/hs-tls-extra&quot;</span>,<span class="st">&quot;/aculich/fix-symbols-gitit&quot;</span>,
    <span class="st">&quot;/sphynx/euler-hs&quot;</span>,<span class="st">&quot;/DRMacIver/unordered-containers&quot;</span>,<span class="st">&quot;/hamishmack/yesod-slides&quot;</span>,
    <span class="st">&quot;/GNUManiacs/hoppla&quot;</span>,<span class="st">&quot;/DRMacIver/hs-rank-aggregation&quot;</span>,<span class="st">&quot;/naota/hackage-autoebuild&quot;</span>,<span class="st">&quot;/magthe/hsini&quot;</span>,
    <span class="st">&quot;/dagit/gnuplot-test&quot;</span>,<span class="st">&quot;/imbaczek/HBPoker&quot;</span>,
    <span class="st">&quot;/sergeyastanin/simpleea&quot;</span>,<span class="st">&quot;/cbaatz/hamu808a0&quot;</span>,<span class="st">&quot;/aristidb/xml-enumerator&quot;</span>,<span class="st">&quot;/elliottt/value-supply&quot;</span>,
    <span class="st">&quot;/gnumaniacs-org/hoppla&quot;</span>,<span class="st">&quot;/emillon/tyson&quot;</span>,
    <span class="st">&quot;/quelgar/hifive&quot;</span>,<span class="st">&quot;/quelgar/haskell-websockets&quot;</span>]</code></pre>
</section>
<section id="transforming-links-the-lazy-way" class="level2">
<h2>Transforming links (the lazy way)</h2>
<p>Looks good! We can rest confident. We now have most of our toolkit. What we have left to do is to turn a repo‚Äôs relative address into an absolute address we could pass to an invocation of git, figure out how to shell out to <code>git clone</code>, and then put it all together with some <code>mapM</code> plumbing.</p>
<p>So here‚Äôs how things go:</p>
<ol type="1">
<li>We get the very first index with <code>openURL</code> and save the delicious HTML contents</li>
<li>We parse that with <code>linkify</code> and then our laboriously worked out <code>lastPage</code> will tell us the # of the oldest index</li>
<li>With that knowledge, we know how many URLs to ask <code>listPages</code> for</li>
<li>Now we call <code>openURL</code> on all <em>those</em> URLs</li>
<li>Parse their results and extract, not the index pages, but the repository pages</li>
<li>Somehow turn them into git-comprehensible URLs</li>
<li>Somehow run git on all said URLs</li>
</ol>
<p>1-5 are straightforward given what we already have:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span> html <span class="ot">&lt;-</span> openURL <span class="st">&quot;https://github.com/languages/Haskell/created&quot;</span>
          <span class="kw">let</span> lst <span class="fu">=</span> lastPage <span class="fu">$</span> linkify html
          <span class="kw">let</span> indxPgs <span class="fu">=</span> take lst listPages
          <span class="co">-- we should split out the clause out as a function like `getRepos`</span>
          repourls <span class="ot">&lt;-</span> mapM (fmap repos <span class="fu">.</span> openURL) indxPgs
          <span class="fu">???</span>
          <span class="fu">???</span></code></pre>
<p>Hopefully turning a relatively repository URL into an absolute git URL will be a pure operation, so let‚Äôs tentatively define that function as <code>gitify :: String -&gt; String</code>. Let‚Äôs look at a random repository page <a href="https://github.com/hamishmack/yesod-slides">https://github.com/hamishmack/yesod-slides</a> (in our example output as <code>/hamishmack/yesod-slides</code>), whose git repository is at‚Ä¶ <code>https://github.com/hamishmack/yesod-slides.git</code>! What luck, there‚Äôs an obvious transformation there:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gitify ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
gitify x <span class="fu">=</span> <span class="st">&quot;https://github.com&quot;</span> <span class="fu">++</span> x <span class="fu">++</span> <span class="st">&quot;.git&quot;</span></code></pre>
</section>
<section id="shelling-out-to-git" class="level2">
<h2>Shelling out to git</h2>
<p>That leaves the ‚Äòshell out to git‚Äô functionality. We could try stealing the <a href="http://www.haskell.org/hoogle/?hoogle=spawn" title="Hoogle: spawn">spawn</a> (call out to <code>/bin/sh</code>) code from XMonad, but the point of <code>spawn</code> is that it <a href="http://en.wikipedia.org/wiki/Fork%20%28operating%20system%29" title="Wikipedia: Fork (operating system)">forks</a> away completely from our script, which will completely screw up our desired <em>lack</em> of parallelism.<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> I ultimately wound up using a function from <a href="http://www.haskell.org/hoogle/?hoogle=System.Process" title="Hoogle: System.Process">System.Process</a>, <a href="http://www.haskell.org/hoogle/?hoogle=readProcessWithExitCode" title="Hoogle: readProcessWithExitCode">readProcessWithExitCode</a>. (Why <code>readProcessWithExitCode</code> and not <code>readProcess</code>? Because if a directory already exists, git/<code>readProcess</code> throws an exception which kills the script!) This will work:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shellToGit ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
shellToGit u <span class="fu">=</span> <span class="kw">do</span> (_,y,_) <span class="ot">&lt;-</span> readProcessWithExitCode <span class="st">&quot;git&quot;</span> [<span class="st">&quot;clone&quot;</span>, u] <span class="st">&quot;&quot;</span>
                  print y</code></pre>
<p>In retrospect, it might have been a better idea to try to use <a href="http://www.haskell.org/hoogle/?hoogle=runCommand" title="Hoogle: runCommand"><code>runCommand</code></a> or <a href="http://www.haskell.org/hoogle/?hoogle=System.Cmd" title="Hoogle: System.Cmd"><code>System.Cmd</code></a>. Alternatively, we could use the same shelling out functionality from the original <a href="http://patch-tag.com/r/tphyahoo/mirrorpatchtag/snapshot/current/content/pretty/patch-tag-mirror.hs">patch-tag.com</a> script:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">mapM_ (\x <span class="ot">-&gt;</span> runProcess <span class="st">&quot;darcs&quot;</span> [<span class="st">&quot;get&quot;</span>, <span class="st">&quot;--lazy&quot;</span>, <span class="st">&quot;http://patch-tag.com&quot;</span><span class="fu">++</span>x]
                          <span class="dt">Nothing</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span>) targets</code></pre>
<p>Which could be rewritten for us (sans logging) as</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shellToGit ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
shellToGit u <span class="fu">=</span> runProcess <span class="st">&quot;git&quot;</span> [<span class="st">&quot;clone&quot;</span>, u] <span class="dt">Nothing</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span> <span class="fu">&gt;&gt;</span> return ()
<span class="co">-- We could replace `return ()` with Control.Monad.void to drop `IO ProcessHandle` result</span></code></pre>
<p>Now it‚Äôs easy to fill in our 2 missing lines:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">          <span class="fu">...</span>
          repourls <span class="ot">&lt;-</span> mapM getRepos indxPgs
          <span class="kw">let</span> gitURLs <span class="fu">=</span> map gitify <span class="fu">$</span> concat repourls
          mapM_ shellToGit gitURLs</code></pre>
<p>(The <code>concat</code> is there because <code>getRepos</code> gave us a <code>[String]</code> for each <code>String</code>, and then we ran it on a <code>[String]</code> - so our result is <code>[[String]]</code>! But we don‚Äôt care about preserving the information about where each String came from, so we smush it down to a single list. Strictly speaking, we didn‚Äôt need to do <code>print y</code> in <code>shellToGit</code>, but while developing, it‚Äôs a good idea to have some sort of logging - get a sense of what the script is doing. And once you are printing at all, you can <code>sort</code> the list of repository URLs to download them in order by user.)</p>
<section id="unique-repositories" class="level3">
<h3>Unique repositories</h3>
<p>There is one subtlety here worth noting that our script is running rough-shod over. Each URL we download is unique, because usernames are unique on GitHub and each URL is formed from a ‚Äú/username/reponame‚Äù pair. But each <em>downloaded</em> repository is <em>not</em> unique, because git will shuck off the username and create a directory with just the repository name - ‚Äú/john/bar‚Äù and ‚Äú/jack/bar‚Äù will clash, and if you download in that order, the <code>bar</code> repository will be John‚Äôs repository and not Jack‚Äôs repository. Git will error out the second time, but this error is ignored by the shelling code. The solution would be to tell git to <code>clone</code> to a non-default but unique directory (for example, one could reuse the ‚Äú/username/reponame‚Äù and then one‚Äôs target directory would be neatly populated by several hundred directories named after users, each populated by a few repositories with non-unique names). If we went with the per-user approach, our new version would look like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shellToGit ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
shellToGit u <span class="fu">=</span> <span class="kw">do</span> (_,y,_) <span class="ot">&lt;-</span> readProcessWithExitCode <span class="st">&quot;git&quot;</span> [<span class="st">&quot;clone&quot;</span>, u, drop <span class="dv">19</span> u] <span class="st">&quot;&quot;</span>
                  print y</code></pre>
<p>Why the <code>drop 19 u</code>? Well, <code>u</code> is the fully qualified URL, eg. ‚Äúhttps://www.github.com/sergeyastanin/simpleea‚Äù. Obviously we don‚Äôt want to execute <code>git clone &quot;https://www.github.com/sergeyastanin/simpleea&quot; &quot;https://www.github.com/sergeyastanin/simpleea&quot;</code> (even though that‚Äôd be perfectly valid), because it makes for ugly folders. But <code>drop 19 &quot;https://www.github.com/sergeyastanin/simpleea&quot;</code> turns into ‚Äúsergeyastanin/simpleea‚Äù, giving us the right local directory name with no prefixed slash.</p>
<p>Or you just pass in the original ‚Äú/username/reponame‚Äù and use <code>drop 1</code> on that instead. (Either way, you need to do additional work. Might as well just use <code>drop 19</code>.)</p>
<p>One final note: many of the URLs end in ‚Äú.git‚Äù. If we disliked this, then we could enhance the <code>drop 19</code> with <a href="http://www.haskell.org/hoogle/?hoogle=System.FilePath.dropExtension" title="Hoogle: System.FilePath.dropExtension">System.FilePath.dropExtension</a>: <code>dropExtension $ drop 19 u</code>.</p>
</section>
</section>
<section id="the-script" class="level2">
<h2>The script</h2>
<p>The final program, clean of -Wall or <a href="http://hackage.haskell.org/package/hlint" title="Hackage: hlint">hlint</a> warnings:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span> (elemIndices, isPrefixOf, sort)
<span class="kw">import </span><span class="dt">Network.Curl</span> (curlGetString, <span class="dt">URLString</span>)
<span class="kw">import </span><span class="dt">System.FilePath</span> (dropExtension)
<span class="kw">import </span><span class="dt">System.Process</span> (readProcessWithExitCode)
<span class="kw">import </span><span class="dt">Text.HTML.TagSoup</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span> html <span class="ot">&lt;-</span> openURL <span class="st">&quot;https://github.com/languages/Haskell/created&quot;</span>
          <span class="kw">let</span> lst <span class="fu">=</span> lastPage <span class="fu">$</span> linkify html
          <span class="kw">let</span> indxPgs <span class="fu">=</span> take lst listPages
          repourls <span class="ot">&lt;-</span> mapM getRepos indxPgs
          <span class="kw">let</span> gitURLs <span class="fu">=</span> map gitify <span class="fu">$</span> sort <span class="fu">$</span> concat repourls
          mapM_ shellToGit gitURLs

<span class="ot">openURL ::</span> <span class="dt">URLString</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span>
openURL target <span class="fu">=</span> fmap snd <span class="fu">$</span> curlGetString target []

<span class="ot">linkify ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
linkify l <span class="fu">=</span> [x <span class="fu">|</span> <span class="dt">TagOpen</span> <span class="st">&quot;a&quot;</span> atts <span class="ot">&lt;-</span> parseTags l, (_,x) <span class="ot">&lt;-</span> atts]

<span class="ot">lastPage ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
lastPage <span class="fu">=</span> maximum <span class="fu">.</span> map (read <span class="fu">.</span> drop <span class="dv">32</span>) <span class="fu">.</span> filter (<span class="st">&quot;/languages/Haskell/created?page=&quot;</span> <span class="ot">`isPrefixOf`</span>)

<span class="ot">listPages ::</span> [<span class="dt">String</span>]
listPages <span class="fu">=</span> map (\x <span class="ot">-&gt;</span> <span class="st">&quot;https://github.com/languages/Haskell/created?page=&quot;</span> <span class="fu">++</span> show x) [(<span class="dv">1</span><span class="ot">::</span><span class="dt">Int</span>)<span class="fu">..</span>]

<span class="ot">repos ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
repos <span class="fu">=</span> uniq <span class="fu">.</span> linkify
  <span class="kw">where</span><span class="ot">  uniq ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> [<span class="dt">String</span>]
         uniq <span class="fu">=</span> filter count <span class="fu">.</span> filter (\x <span class="ot">-&gt;</span> not <span class="fu">$</span> any (<span class="ot">`isPrefixOf`</span> x) exceptions)
<span class="ot">         exceptions ::</span> [<span class="dt">String</span>]
         exceptions <span class="fu">=</span> [<span class="st">&quot;/languages/&quot;</span>, <span class="st">&quot;/login/&quot;</span>, <span class="st">&quot;/site/&quot;</span>, <span class="st">&quot;http://&quot;</span>, <span class="st">&quot;https://&quot;</span>]
<span class="ot">         count ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
         count x <span class="fu">=</span> length (elemIndices <span class="ch">'/'</span> x) <span class="fu">==</span> <span class="dv">2</span>

<span class="ot">getRepos ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">String</span>]
getRepos <span class="fu">=</span> fmap repos <span class="fu">.</span> openURL

<span class="ot">gitify ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
gitify x <span class="fu">=</span> <span class="st">&quot;https://github.com&quot;</span> <span class="fu">++</span> x <span class="fu">++</span> <span class="st">&quot;.git&quot;</span>

<span class="ot">shellToGit ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
shellToGit u <span class="fu">=</span> <span class="kw">do</span> (_,y,_) <span class="ot">&lt;-</span> readProcessWithExitCode <span class="st">&quot;git&quot;</span> [<span class="st">&quot;clone&quot;</span>, u, dropExtension <span class="fu">$</span> drop <span class="dv">19</span> u] <span class="st">&quot;&quot;</span>
                  print y</code></pre>
<p>This, or a version of it, works well. But I caution people from mis-using it! There are a <em>lot</em> of repositories on GitHub; please don‚Äôt go running this carelessly. It will pull down 4-12 gigabytes of data. GitHub is a good FLOSS-friendly business by all accounts, and doesn‚Äôt deserve people wasting its bandwidth &amp; money if they are not even going to keep what they downloaded.</p>
<section id="the-script-golfed" class="level3">
<h3>The script golfed</h3>
<p>For kicks, let‚Äôs see what a shorter, more unmaintainable and unreadable, version looks like (in the best scripting language tradition):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span> (elemIndices, isPrefixOf, sort)
<span class="kw">import </span><span class="dt">Network.Curl</span> (curlGetString)
<span class="kw">import </span><span class="dt">System.FilePath</span> (dropExtension)
<span class="kw">import </span><span class="dt">System.Process</span> (readProcessWithExitCode)
<span class="kw">import </span><span class="dt">Text.HTML.TagSoup</span>

main <span class="fu">=</span> <span class="kw">do</span> html <span class="ot">&lt;-</span> openURL <span class="st">&quot;https://github.com/languages/Haskell/created&quot;</span>
          <span class="kw">let</span> i <span class="fu">=</span> take (lastPage <span class="fu">$</span> linkify html) <span class="fu">$</span>
                   map ((<span class="st">&quot;https://github.com/languages/Haskell/created?page=&quot;</span><span class="fu">++</span>) <span class="fu">.</span> show) [<span class="dv">1</span><span class="fu">..</span>]
          repourls <span class="ot">&lt;-</span> mapM (fmap (uniq <span class="fu">.</span> linkify) <span class="fu">.</span> openURL) i
          mapM_ shellToGit <span class="fu">$</span> map (\x <span class="ot">-&gt;</span> <span class="st">&quot;https://github.com&quot;</span> <span class="fu">++</span> x <span class="fu">++</span> <span class="st">&quot;.git&quot;</span>) <span class="fu">$</span> sort <span class="fu">$</span> concat repourls
       <span class="kw">where</span> openURL target <span class="fu">=</span> fmap snd <span class="fu">$</span> curlGetString target []
             linkify l <span class="fu">=</span> [x <span class="fu">|</span> <span class="dt">TagOpen</span> <span class="st">&quot;a&quot;</span> atts <span class="ot">&lt;-</span> parseTags l, (_,x) <span class="ot">&lt;-</span> atts]
             lastPage <span class="fu">=</span> maximum <span class="fu">.</span> map (read <span class="fu">.</span> drop <span class="dv">32</span>) <span class="fu">.</span>
                         filter (<span class="st">&quot;/languages/Haskell/created?page=&quot;</span> <span class="ot">`isPrefixOf`</span>)
             uniq <span class="fu">=</span> filter count <span class="fu">.</span> filter (\x <span class="ot">-&gt;</span> not <span class="fu">$</span> any (<span class="ot">`isPrefixOf`</span> x)
                     [<span class="st">&quot;/languages/&quot;</span>, <span class="st">&quot;/login/&quot;</span>, <span class="st">&quot;/site/&quot;</span>, <span class="st">&quot;http://&quot;</span>, <span class="st">&quot;https://&quot;</span>])
             count x <span class="fu">=</span> length (elemIndices <span class="ch">'/'</span> x) <span class="fu">==</span> <span class="dv">2</span>
             shellToGit u <span class="fu">=</span> <span class="kw">do</span> { (_,y,_) <span class="ot">&lt;-</span> readProcessWithExitCode <span class="st">&quot;git&quot;</span>
                                             [<span class="st">&quot;clone&quot;</span>, u, dropExtension <span class="fu">$</span> drop <span class="dv">19</span> u] <span class="st">&quot;&quot;</span>; print y }</code></pre>
<p>14 lines of code isn‚Äôt too bad, especially considering that Haskell is not usually considering a language suited for scripting or scraping purposes like this. Nor do I see any obvious missing abstractions - <code>count</code> is a function that might be useful in <code>Data.List</code>, and <code>openURL</code> is something that the Curl binding could provide on its own, but everything else looks pretty necessary.</p>
</section>
</section>
</section>
<section id="exercises-for-the-reader" class="level1">
<h1>Exercises for the reader</h1>
<ol type="1">
<li>Once one has all those repositories, how does one keep them up to date? The relevant command is <code>git pull</code>. How would one run this on all the repositories? In shell script? Using <code>find</code>? From a crontab?<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a></li>
<li>In the previous script, a number of short-cuts were taken which render it Haskell-specific. Identify and remedy them, turning this script into a general-purpose script for downloading <em>any</em> language for which GitHub has a category. (The language name can be accessed by reading an argument to the script by standard functions like <a href="http://www.haskell.org/hoogle/?hoogle=getArgs" title="Hoogle: getArgs">getArgs</a>.)</li>
</ol>
</section>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><p>This page assumes a basic understanding of how version control programs work, Haskell syntax, and the Haskell standard library. For those not <em>au courant</em>, repositories are basically a collection of logically related files and a detailed history of the modifications that built them up from nothing.<a href="#fnref1">‚Ü©</a></p></li>
<li id="fn2"><p>From my <a href="http://web.archive.org/web/20130128084740/http://www.haskell.org/pipermail/libraries/2009-June/011880.html" title="Adding an ignore function to Control.Monad">initial email</a>:</p>
<blockquote>
<p>I‚Äôd think it [<code>Control.Monad.void</code>] [would] be useful for more than just me. Agda is lousy with calls to <code>&gt;&gt; return ()</code>; and then there‚Äôs ZMachine, arrayref, whim, the barracuda packages, binary, bnfc, buddha, bytestring, c2hs, cabal, chesslibrary, comas, conjure, curl, darcs, darcs-benchmark, dbus-haskell, ddc, dephd, derive, dhs, drift, easyvision, ehc, filestore, folkung, geni, geordi, gtk2hs, gnuplot, ginsu, halfs, happstack, haskeline, hback, hbeat‚Ä¶ You get the picture.</p>
</blockquote>
<a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><p>I occasionally also use Haskell scripts based on <a href="http://hackage.haskell.org/package/haskell-src-exts" title="Hackage: haskell-src-exts">haskell-src-exts</a>.<a href="#fnref3">‚Ü©</a></p></li>
<li id="fn4"><p>Besides <code>curl</code>, there is the <a href="http://hackage.haskell.org/package/http-wget" title="Hackage: http-wget">http-wget</a> wrapper, and the <a href="http://hackage.haskell.org/package/http-enumerator" title="Hackage: http-enumerator">http-enumerator</a> package claims to natively support HTTPS. I have not tried them.<a href="#fnref4">‚Ü©</a></p></li>
<li id="fn5"><p>What would we do? Keep retrying? There are going to be tons of errors in this script anyway, from repositories incorrectly identified as Haskell-related to repository duplicates to transient network errors, that we gain a great deal of complexity from retrying and may make the script <em>less</em> reliable.<a href="#fnref5">‚Ü©</a></p></li>
<li id="fn6"><p>Oh no - a blacklist! This should make us unhappy, because as computer security has taught us, blacklists fall out of date quickly or were never correct to begin with. Much better to whitelist, but how can we do that? People could name their repositories any damn thing, and pick any accursed username; for all our code knows, ‚Äò/site/terms‚Äô <em>is</em> the repository - perhaps the user ‚Äòsite‚Äô maintains some sort a natural language library called ‚Äòterms‚Äô.<a href="#fnref6">‚Ü©</a></p></li>
<li id="fn7"><p>A quick point: in the previous scripts, I went to some effort to get greater parallelism, but in this case, we don‚Äôt want to hammer GitHub with a few thousand simultaneous <code>git clone</code> invocations; Haskell repositories are created rarely enough that we can afford to be friendly and only download one repository at a time.<a href="#fnref7">‚Ü©</a></p></li>
<li id="fn8"><p>Example cron answer: <code>@weekly find ~/bin -type d -name &quot;.git&quot; -execdir nice git pull \;</code><a href="#fnref8">‚Ü©</a></p></li>
</ol>
</section>
</div>
</div>
<div id="footer">
<p>Still bored? Then try my <a href="https://plus.google.com/103530621949492999968/posts" title="Google+ posts">Google+ news feed</a>.</p>
<a href="https://docs.google.com/spreadsheet/viewform?formkey=dE5GLWpfX3RhX1c2Q1phcEo3U3VDVEE6MQ">Send anonymous feedback</a>
<br/>
<div id="license">
<p xmlns:dct="http://purl.org/dc/terms/" xmlns:vcard="http://www.w3.org/2001/vcard-rdf/3.0#">
<a rel="license" href="http://creativecommons.org/publicdomain/zero/1.0/">
<img src="http://i.creativecommons.org/p/zero/1.0/88x31.png" style="border-style: none;" alt="CC0" height="31" width="88"/>
</a>
</p>
</div>
</div>
 
<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
 
<script type="text/javascript" src="../static/js/footnotes.js"></script>
 
<script type="text/javascript" src="../static/js/abalytics.js"></script>
<script type="text/javascript">
      window.onload = function() {
      ABalytics.applyHtml();
      };
    </script>
 
<script id="googleAnalytics" type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-18912926-1']);

      ABalytics.init({
      indent: [
      {
      name: "none",
      "indent_class1": "<style>p + p { text-indent: 0.0em; margin-top: 0 }</style>"
      },
      {
      name: "indent0.1",
      "indent_class1": "<style>p + p { text-indent: 0.1em; margin-top: 0 }</style>"
      },
      {
      name: "indent0.5",
      "indent_class1": "<style>p + p { text-indent: 0.5em; margin-top: 0 }</style>"
      },
      {
      name: "indent1.0",
      "indent_class1": "<style>p + p { text-indent: 1.0em; margin-top: 0 }</style>"
      },
      {
      name: "indent1.5",
      "indent_class1": "<style>p + p { text-indent: 1.5em; margin-top: 0 }</style>"
      },
      {
      name: "indent2.0",
      "indent_class1": "<style>p + p { text-indent: 2.0em; margin-top: 0 }</style>"
      }
      ],
      }, _gaq);

      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
 
<script id="outboundLinkTracking" type="text/javascript">
      $(function() {
      $("a").on('click',function(e){
      var url = $(this).attr("href");
      if (e.currentTarget.host != window.location.host) {
      _gat._getTrackerByName()._trackEvent("Outbound Links", e.currentTarget.host.replace(':80',''), url, 0);
      if (e.metaKey || e.ctrlKey || (e.button == 1)) {
      var newtab = true;
      }
      if (!newtab) {
      e.preventDefault();
      setTimeout('document.location = "' + url + '"', 100);
      }
      }
      });
      });
    </script>
 
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
 
<script type="text/javascript" src="../static/js/footnotes.js"></script>
 
<script type="text/javascript" src="../static/js/tablesorter.js"></script>
<script type="text/javascript" id="tablesorter">
      $(document).ready(function() {
      $("table").tablesorter();
      }); </script>
 
<div id="disqus_thread"></div>
<script type="text/javascript">
      if (document.title != 'Essays') { <!-- avoid Disqus comments on front page -->
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://disqus.com/forums/gwern/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
      var disqus_shortname = 'gwern';
      (function () {
      var s = document.createElement('script'); s.async = true;
      s.src = 'http://disqus.com/forums/gwern/count.js';
      (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
      }());
      }</script>
<noscript><p>Enable JavaScript for Disqus comments</p></noscript>
</body>
</html>

